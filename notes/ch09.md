# Streams as values

## Dealing with an unknown number of values

### Requirements: Online currency exchange

1. The user can request an exchange of a given amount of money from one currency to another currency.
2. A requested exchange should be performed only when the exchange rate between the given pair of currencies is trending, which means that each of the last n rates is higher than the previous one—for example, 0.81, 0.82, 0.85 is a trend, while 0.81, 0.80, 0.85 is not (for n=3).
3. We are given the API call function (`exchangeTable`) that fetches only the current exchange rates table from a given currency to all other supported currencies.


## The functional approach to the design

```scala
object model {
  opaque type Currency = String
  object Currency {
    def apply(name: String): Currency = name
    extension (currency: Currency) def name: String = currency
  }
}
import model._

def exchangeTable(from: Currency): IO[Map[Currency, BigDecimal]]
```

## Practicing immutable maps

```scala
val m1: Map[String, String] = Map("key" -> "value")
val m2: Map[String, String] = m1.updated("key2", "value2")
val m3: Map[String, String] = m2.updated("key2", "another2")
val m4: Map[String, String] = m3.removed("key")
val valueFromM3: Option[String] = m3.get("key")
val valueFromM4: Option[String] = m4.get("key")

Map(Currency(EUR) -> 0.83)
Map.empty
Map(Currency(EUR) -> 0.82)
Some(BigDecimal(0.82))
None
```

## Pattern matching on tuples

```scala
def trending(rates: List[BigDecimal]): Boolean = {
  rates.size && rates.zip(rates.drop(1)).forall(ratePair => ratePair match {
    case (previousRate, rate) => rate > previousRate
  })
}
```

## Coffee break: Working with maps and tuples

```scala
def extractSingleCurrencyRate(currencyToExtract: Currency)(table: Map[Currency, BigDecimal]): Option[BigDecimal] = {
  table.get(currencyToExtract)
}
```

## Functional jigsaw puzzle

```scala
def exchangeTable(from: Currency): IO[Map[Currency, BigDecimal]] = {
  IO.delay(exchangeRatesTableApiCall(from.name)).map(table => table.map(kv => kv match {
    case (currency, rate) => (Currency(currency), rate)
  }))
}
```

## Following types in a bottom-up design

```scala
import ch08_SchedulingMeetings.retry
def lastRates(from: Currency, to: Currency): IO[List[BigDecimal]] = {
  for {
    table1 <- retry(exchangeTable(from), 10)
    table2 <- retry(exchangeTable(from), 10)
    table3 <- retry(exchangeTable(from), 10)
    lastTables = List(table1, table2, table3)
  } yield lastTables.flatMap(extractSingleCurrencyRate(to))
}

def exchangeIfTrending(amount: BigDecimal, from: Currency, to: Currency): IO[Option[BigDecimal]] = {
  lastRates(from, to).map(rates => if (trending(rates)) Some(amount * rates.last) else None)
}
```

## Recursive functions

```scala
def exchangeIfTrending(amount: BigDecimal, from: Currency, to: Currency): IO[Option[BigDecimal]] = {
  for {
    rates <- lastRates(from, to)
    result <- if (trending(rates)) IO.pure(Some(amount * rates.last))
              else exchangeIfTrending(amount, from, to)
  } yield result
}
```

## Dealing with an absence in the future (using recursion)

We can model a possible absence of a trend with possibly infinite recursive calls instead of an `Option`.

```scala
def exchangeIfTrending(amount: BigDecimal, from: Currency, to: Currency): IO[BigDecimal] = {
  for {
    rates <- lastRates(from, to)
    result <- if (trending(rates)) IO.pure(amount * rates.last)
              else exchangeIfTrending(amount, from, to)
  } yield result
}
```

## Coffee break: Recursion and infinity

```scala
def currencyRate(from: Currency, to: Currency): IO[BigDecimal] = {
  for {
    table <- retry(exchangeTable(from), 10)
    possibleRate <- extractSingleCurrencyRate(to)(table)
    rate <- possibleRate match {
      case Some(rate) => IO.pure(rate)
      case None => currencyRate(from, to)
    }
  } yield rate
}
```

## Stream processing, producers, and consumers

Producer
- Responsible for defining source data
- May be finite or infinite
- A `Stream` value in JAva or a generator in Python
- May be defined in terms of other producers

Consumer
- Responsible for using data generated by a producer
- Creates a final value
- `collect` or `count` functions in Java
- Doesn't usually return a new stream

## Streams are recursive values

```scala
def numbers(): Stream[Pure, Int] =
  Stream(1, 2, 3).append(numbers())
```

## Primitive operations and combinators

1. `List(1, 1, 1)`
2. `List(1, 0, 1, 0)`
3. `List(26)`
4. `List(13, 13)`

## Practicing stream operations

```scala
val infiniteDieCasts: Stream[IO, Int] = Stream.eval(castTheDie()).repeat

// 1. Filter odd numbers, and return the first three such casts.
infiniteDieCasts.filter(_ % 2 != 0).take(3).compile.toList
// 2. Return the first five die casts, but make sure all 6 values are doubled
infiniteDieCasts.take(5).map(x => if (x == 6) x * 2 else x).compile.toList
// 3. Return the sum of the first three casts.
infiniteDieCasts.take(3).compile.toList.sum
// 4. Cast the die until there is a 5 and then cast it two more times, returning three last results back (a 5 and two more).
infiniteDieCasts.filter(_ == 5).take(1).append(infiniteDieCasts.take(2)).compile.toList
// 5. Make sure the die is cast 100 times, and values are discarded.
infiniteDieCasts.take(100).compile.drain
// 6. Return the first three casts unchanged and the next three casts tripled (six in total).
infiniteDieCasts.take(3).append(infiniteDieCasts.take(3).map(_ * 3)).compile.toList
// 7. Cast the die until there are two 6s in a row.
infiniteDieCasts.scan(0)((sixesInRow, current) => if (current == 6) sixesInRow + 1 else 0).filter(_ == 2).take(1).compile.toList
```

## Infinite stream of API calls

```scala
def rates(from: Currency, to: Currency): Stream[IO, BigDecimal] =
  Stream.eval(exchangeTable)
    .repeat
    .map(extractSingleCurrencyRate(to))
    .unNone
```

## Separated concerns

```scala
def rates(from: Currency, to: Currency): Stream[IO, BigDecimal] =
  Stream.eval(exchangeTable)
    .repeat
    .map(extractSingleCurrencyRate(to))
    .unNone
    .orElse(rates(from, to))
```

## Sliding windows

```scala
def exchangeIfTrending(amount: BigDecimal, from: Currency, to: Currency): IO[BigDecimal] = {
  rates(from, to)
    .sliding(3)
    .map(_.toList)
    .filter(trending)
    .map(_.last)
    .take(1)
    .compile
    .lastOrError
    .map(_ * amount)
}
```

## Waiting between IO calls

```scala
val delay: FiniteDuration = FiniteDuration(1, TimeUnit.SECONDS)
val ticks: Stream[IO, Unit] = Stream.fixedRate[IO](delay)
val firstThreeRates: IO[List[(BigDecimal, Unit)]] =
  rates(Currency("USD"), Currency("EUR"))
    .zip(ticks).take(3).compile.toList
```

When we zip two streams, we need to wait for an element from both streams to produce an element of the combined stream.

## Zipping streams

```scala
def exchangeIfTrending(amount: BigDecimal, from: Currency, to: Currency): IO[BigDecimal] = {
  rates(from, to)
    .zipLeft(ticks)
    .sliding(3)
    .map(_.toList)
    .filter(trending)
    .map(_.last)
    .take(1)
    .compile
    .lastOrError
    .map(_ * amount)
}
```

## Benefits of using the stream-based approach

- Definition of a stream is separated from its use site
- Nothing is done until it’s really needed
- The high-level API enables us to focus on the business domain instead
of implementation details
- More separated concern
- Composability
- Encapsulating asynchronous boundaries

## Summary

### Declaratively design complicated program flows

### Use recursion and laziness to defer some decisions

### Handle IO-based streams of data

### Create and handle infinite stream of values

### Isolate time-dependent functionalities
